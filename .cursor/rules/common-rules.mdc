---
description: 
globs: 
alwaysApply: true
---
# Clean Code & High-Quality Development Guidelines
## 1. 코드 구조 & 가독성

1.  **단일 책임 원칙 (Single Responsibility Principle)**
    * 각 파일, 클래스, 함수는 **딱 하나의 역할**만 담당하도록 설계합니다.
    * 여러 가지 로직이 한 곳에 섞여 있으면 모듈화를 통해 분리하세요.

    > **참고:** SRP는 SOLID 원칙 중 하나입니다. 설계 시 유연성과 유지보수성을 높이려면,
    > **OCP(개방-폐쇄), LSP(리스코프 치환), ISP(인터페이스 분리), DIP(의존 역전)** 등 **SOLID 전반**을 함께 적용하는 것이 좋습니다.

2.  **폴더 및 파일 구조**
    * 폴더 구조는 도메인 또는 기능 단위로 분리해, 탐색이 직관적이도록 만듭니다.
    * 파일명은 해당 로직의 핵심 기능을 분명히 드러내는 이름으로 짓습니다.

3.  **짧은 함수와 메서드**
    * 함수는 **25줄**을 넘기지 않도록 하여, 단일 개념에 집중하게 합니다.
    * 긴 함수를 발견하면 바로 로직을 세분화하여 분리합니다.

---

## 2. 명명 규칙 & 스타일

1.  **의도가 드러나는 명칭**
    * 변수, 함수, 클래스 이름에 해당 대상의 **역할과 의도**가 분명히 나타나도록 합니다.
    * 축약어를 지양하고, 검색 가능한 이름을 사용합니다. (예: `userProfile`, `WorkspaceUserData` 등)

2.  **일관된 컨벤션**
    * CamelCase, PascalCase 등 프로젝트 내에서 합의된 컨벤션을 철저히 지킵니다.
    * 함수와 변수는 소문자 시작(예: `doSomething`), 클래스와 타입은 대문자 시작(예: `UserModel`)처럼 역할별 구분을 명확히 합니다.

3.  **자동화된 포매터 & 린터**
    * ESLint 등 린트 툴과 Prettier 등 포매터를 도입해 **코드 스타일을 자동**으로 유지합니다.
    * 전역에서 동일한 규칙을 적용하여, 스타일 문제로 인한 코드 이력을 최소화합니다.

---

## 3. DRY 원칙 & 중복 제거

1.  **중복 로직 파악**
    * 같은 로직이 여러 곳에서 반복되면, 즉시 공용 함수(또는 모듈)로 추출합니다.
    * 상수를 여러 곳에서 참조할 경우, 공통 상수 파일을 만들어 공유합니다.

2.  **함수 및 컴포넌트 재사용성**
    * 범용적으로 사용 가능한 로직이라면, 특정 모듈에만 국한되지 않도록 **재사용 가능**한 구조로 작성합니다.
    * UI 컴포넌트(React 등)도 **범용성**을 먼저 고려하고, 필요 시 확장을 쉽게 할 수 있도록 만듭니다.

3.  **템플릿화**
    * 반복되는 텍스트나 코드를 **템플릿**으로 만들어두고 동적으로 데이터를 주입하는 방식을 사용하면 유지보수 비용이 줄어듭니다.

---

## 4. 모듈화 & 계층 분리

1.  **핵심 로직 vs. 보조 로직 분리**
    * 비즈니스 로직(핵심)과 인프라/도구 로직(보조)을 다른 모듈에 배치하여 관심사를 분리합니다.
    * 예: `controllers/` 디렉터리는 요청-응답 처리, `services/`는 핵심 비즈니스 로직, `utils/`는 범용 유틸 함수 등.

2.  **명확한 의존성 방향**
    * 하위(낮은 수준) 모듈이 상위(높은 수준) 모듈을 참조하지 않도록 의존성 흐름을 한 방향으로 고정합니다.
    * 의존성 주입(DI) 패턴을 활용해 테스트와 재사용성을 극대화할 수 있습니다.

3.  **재사용 가능한 라이브러리화**
    * 공통으로 사용되는 로직은 별도 라이브러리(패키지)나 유틸 디렉터리로 옮겨, 프로젝트 전체에서 재사용할 수 있도록 합니다.
    * 버전 관리를 통해 변경 이력과 호환성을 관리합니다.

---

## 5. 불변성 & 순수 함수

1.  **불변 데이터**
    * 가능한 한 **Immutable** 자료 구조를 사용하고, 원본을 직접 수정하지 않습니다.
    * 새로운 변수를 생성해 값을 할당하는 방식으로 사이드 이펙트를 최소화합니다.

2.  **순수 함수(순수성 유지)**
    * 함수 내부에서 외부 상태를 참조하거나 변경하는 것을 피하고, 입력값만으로 동작하도록 작성합니다.
    * 테스트가 용이해지고, 예측 가능성이 높아집니다.

---

## 6. 코드 복잡도 & 유지보수

1.  **Cyclomatic Complexity(순환 복잡도)**
    * 한 함수/메서드 내의 분기(`if`, `switch`)가 많아지면 복잡도가 상승합니다.
    * 복잡도가 10을 넘어서면 함수를 분할하거나 로직을 단순화하는 리팩토링을 고려합니다.

2.  **조건문 단순화**
    * 중첩된 조건문(If-else depth)이 2단계를 넘기지 않도록 주의합니다.
    * Guard clause(초기 return) 등을 사용해 가독성을 높입니다.

3.  **마법 숫자(Magic Number) 제거**
    * 의미가 불분명한 숫자나 문자열 리터럴은 상수나 열거형(enum)으로 추출합니다.
    * 주석 대신 **명확한 상수명**으로 의도를 드러냅니다.

---

## 7. 테스트 전략 & 품질 확보

1.  **핵심 로직 우선 테스트**
    * 가장 중요한 비즈니스 로직부터 철저히 테스트해 결함을 조기에 발견합니다.
    * 유닛 테스트로 각 함수의 입력-출력에 대한 확실한 보증을 만듭니다.

2.  **테스트 커버리지 목표**
    * **단위 테스트(Unit Test)**: 비즈니스 로직의 90% 이상
    * **통합 테스트(Integration)**: 레이어 간 연동이 필요한 핵심 경로
    * **E2E 테스트**: 실제 사용 시나리오의 주요 흐름

3.  **자동화된 테스트 실행**
    * 커맨드 한 번으로 전체 테스트가 수행되도록 설정합니다.
    * 오류 시 즉시 로컬에서 재현 가능하도록, 테스트 환경을 간단하게 유지합니다.

> **추가 팁:**
> * **테스트 피라미드**(단위 → 통합 → E2E)를 기반으로 QA 전략을 설계하면, 단위 테스트로 기초를 탄탄히 하고 통합/시스템/E2E 테스트에서 주요 시나리오를 점검할 수 있습니다.
> * **연기 테스트, 회귀 테스트, 기능 테스트** 등 다양한 기법도 상황에 따라 적극 활용해 결함을 조기에 발견하세요.

---

## 8. 주석과 문서화

1.  **필요 최소한의 주석**
    * 코드는 자기 문서화(self-documenting)가 원칙입니다.
    * 복잡한 알고리즘이나 의도를 명시해야 하는 경우에만, **짧고 명료**하게 주석을 추가합니다.

    > **예:**
    > * 특정 복잡도가 높은 알고리즘의 핵심 로직
    > * 외부 API 호출 시 주의해야 할 파라미터, 사용 제한 등

2.  **Docstring / JSDoc / TSDoc**
    * 함수나 클래스 위에 파라미터, 리턴값, 예외사항을 표시하는 주석을 달아두면 유지보수 시 큰 도움이 됩니다.
    * 자동 문서화 도구와 연동해, API 레퍼런스 등을 쉽게 생성하도록 합니다.

3.  **핵심 설계 문서**
    * 아키텍처나 모듈 설계 의사결정이 중요한 경우, 변경 이력과 함께 간단히 문서화하여 추후 레거시 처리나 확장 시 참고할 수 있게 합니다.

---

## 9. 리팩토링 & 지속적 개선

1.  **지속적 리팩토링**
    * 새 기능 추가 시, 기존 코드를 점검해 **중복 제거**와 구조 개선을 함께 진행합니다.
    * 추후 대규모 수정이 필요하지 않도록 **점진적인 리팩토링**을 습관화합니다.

2.  **기술 부채 관리**
    * 급한 구현으로 인해 임시 방편이 생기면, 반드시 기록해두고 가능한 한 빨리 개선합니다.
    * 주기적으로 코드 스멜(Code Smell)을 확인해, 유지보수성이 떨어지는 부분을 우선적으로 정리합니다.

3.  **자동 분석 툴 활용**
    * 정적 분석(Static Analysis) 도구를 통해 복잡도, 코드 스멜, 사용되지 않는 코드 등을 주기적으로 체크합니다.
    * 코드 커버리지 리포트, 린트 에러 등 품질 지표를 꾸준히 모니터링해 점진적 개선을 유도합니다.

---

## 10. 재사용성과 확장성

1.  **유연한 설계**
    * 변동이 예상되는 부분은 **인터페이스**나 **추상화**를 통해 유연성을 확보합니다.
    * 반드시 필요한 부분에만 인터페이스를 적용하고, **지나친 추상화**로 복잡도가 올라가지 않도록 주의합니다.

2.  **오픈-클로즈드 원칙(개방-폐쇄)**
    * 기능 확장은 쉽고, 기존 코드 변경은 최소화하도록 설계합니다.
    * 예: 전략 패턴, 팩토리 패턴 등을 적용해 로직 확장 시 수정 범위를 최소화할 수 있습니다.

3.  **범용 유틸 기능 분리**
    * 프로젝트 전반에서 사용될 가능성이 있는 유틸 함수(예: 날짜 변환, 문자열 파싱 등)는 별도 모듈로 분리해 재사용합니다.
    * 중복된 유틸 코드가 있으면 즉시 통합하고, 다른 코드에서 참조하도록 유도합니다.

---

## 결론

* **코드는 명확하고 간결하게, 단일 책임을 갖는 구조**로 작성하여 가독성과 유지보수성을 높입니다.
* **DRY 원칙, 모듈화, 재사용성**을 준수해, 중복을 최소화하고 확장하기 쉬운 코드를 만듭니다.
* **테스트와 린팅**을 통해 결함을 조기에 발견하고, **지속적 리팩토링**으로 품질을 유지·개선합니다.
* **SOLID 원칙**을 비롯한 여러 설계 원칙을 적절히 적용하되, **불필요한 복잡성이나 과도한 추상화**는 지양합니다.
* 운영 단계에서도 **로깅, 모니터링, 예외 처리, 보안 검증** 등을 체계적으로 설계하여 문제를 조기 파악하고 빠르게 대응할 수 있도록 준비합니다.

이 가이드를 토대로, 팀 내에서 합의된 컨벤션과 툴(정적 분석, CI/CD, 코드 리뷰 등)을 지속적으로 적용·개선한다면, **20년 차 시니어 개발자도 만족**할 만한 안정적이고 확장 가능한 코드베이스를 유지할 수 있을 것입니다.
